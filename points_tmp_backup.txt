package dev.woori.wooriLearn.domain.account.service;

import dev.woori.wooriLearn.common.HistoryStatus;
import dev.woori.wooriLearn.common.SortDirection;
import dev.woori.wooriLearn.config.exception.CommonException;
import dev.woori.wooriLearn.config.exception.ErrorCode;
import dev.woori.wooriLearn.domain.account.dto.PointsExchangeRequestDto;
import dev.woori.wooriLearn.domain.account.dto.PointsExchangeResponseDto;
import dev.woori.wooriLearn.domain.account.entity.Account;
import dev.woori.wooriLearn.domain.account.entity.PointsHistory;
import dev.woori.wooriLearn.domain.account.entity.PointsHistoryType;
import dev.woori.wooriLearn.domain.account.entity.PointsStatus;
import dev.woori.wooriLearn.domain.account.repository.AccountRepository;
import dev.woori.wooriLearn.domain.account.repository.PointsHistoryRepository;
import dev.woori.wooriLearn.domain.user.entity.Users;
import dev.woori.wooriLearn.domain.user.repository.UserRepository;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.List;

@Service
@RequiredArgsConstructor
public class PointsExchangeService {
    private static final String INSUFFICIENT_POINTS_FAIL_REASON = "INSUFFICIENT_POINTS";
    private static final String PROCESSING_ERROR_FAIL_REASON = "PROCESSING_ERROR";
    private final Clock clock;
    private final PointsHistoryRepository pointsHistoryRepository;
    private final UserRepository userRepository;
    private final AccountRepository accountRepository;


    /* ì¶œê¸ˆ ? ì²­ */
    @Transactional
    public PointsExchangeResponseDto requestExchange(String username, PointsExchangeRequestDto dto) {



        Users user = userRepository.findByUserIdForUpdate(username)
                .orElseThrow(() -> new CommonException(ErrorCode.ENTITY_NOT_FOUND, "?¬ìš©?ë? ì°¾ì„ ???†ìŠµ?ˆë‹¤. userId=" + username));

        // ê¸ˆì•¡ ? íš¨??ë¨¼ì? ê²€ì¦?null/ë¹„ì–‘??
        if (dto.exchangeAmount() == null || dto.exchangeAmount() <= 0) {
            throw new CommonException(ErrorCode.INVALID_REQUEST, "êµí™˜ ? ì²­ ê¸ˆì•¡?€ 0ë³´ë‹¤ ì»¤ì•¼ ?©ë‹ˆ??);
        }
        // ?¬í›„ ?”ì•¡ ë¹„êµ: ì¶©ì¡± ?¬ë? ?•ì¸
        if (user.getPoints() < dto.exchangeAmount()) {
            throw new CommonException(ErrorCode.CONFLICT, "?¬ì¸?¸ê? ë¶€ì¡±í•˜??ì¶œê¸ˆ ? ì²­??ì²˜ë¦¬?????†ìŠµ?ˆë‹¤.");
        }

        Account account = accountRepository.findByAccountNumber(dto.accountNum())
                .orElseThrow(() -> new CommonException(ErrorCode.ENTITY_NOT_FOUND, "ê³„ì¢Œë¥?ì°¾ì„ ???†ìŠµ?ˆë‹¤. accountNum=" + dto.accountNum()));

        if (!account.getUser().getId().equals(user.getId())) {
            throw new CommonException(ErrorCode.FORBIDDEN, "?´ë‹¹ ê³„ì¢Œ???Œìœ ?ê? ?„ë‹™?ˆë‹¤.");
        }

        PointsHistory history = pointsHistoryRepository.save(
                PointsHistory.builder()
                        .user(user)
                        .amount(dto.exchangeAmount())
                        .type(PointsHistoryType.WITHDRAW)
                        .status(PointsStatus.APPLY)
                        .build()
        );

        return PointsExchangeResponseDto.builder()
                .requestId(history.getId())
                .userId(user.getId())
                .exchangeAmount(history.getAmount())
                .status(history.getStatus())
                .requestDate(history.getCreatedAt())
                .message("ì¶œê¸ˆ ? ì²­???•ìƒ?ìœ¼ë¡??‘ìˆ˜?˜ì—ˆ?µë‹ˆ??)
                .build();
    }

    /* ì¶œê¸ˆ ?´ë ¥ ì¡°íšŒ */
    private PointsStatus convertStatus(HistoryStatus status) {
        if (status == null || status == HistoryStatus.ALL) return null;
        return switch (status) {
            case APPLY -> PointsStatus.APPLY;
            case SUCCESS -> PointsStatus.SUCCESS;
            case FAILED -> PointsStatus.FAILED;
            default -> throw new CommonException(ErrorCode.INVALID_REQUEST, "Unknown status: " + status);
        };
    }

    public List<PointsExchangeResponseDto> getHistory(
            String username,
            String startDate,
            String endDate,
            HistoryStatus status,
            SortDirection sort
    ) {
        Long userId = userRepository.findByUserId(username)
                .map(Users::getId)
                .orElseThrow(() -> new CommonException(ErrorCode.ENTITY_NOT_FOUND, "?¬ìš©?ë? ì°¾ì„ ???†ìŠµ?ˆë‹¤. userId=" + username));

        LocalDateTime start = parseStartDate(startDate);
        LocalDateTime end = parseEndDate(endDate);

        PointsStatus statusEnum = convertStatus(status);
        Sort sortOption = sort.toSort("createdAt");

        List<PointsHistory> list = pointsHistoryRepository.findByFilters(
                userId, PointsHistoryType.WITHDRAW, statusEnum, start, end, sortOption
        );

        return list.stream()
                .map(h -> PointsExchangeResponseDto.builder()
                        .requestId(h.getId())
                        .userId(userId)
                        .exchangeAmount(h.getAmount())
                        .status(h.getStatus())
                        .requestDate(h.getCreatedAt())
                        .processedDate(h.getProcessedAt())
                        .message(mapStatusToMessage(h.getStatus()))
                        .build()
                ).toList();
    }

    /* ì¶œê¸ˆ ?¹ì¸ */
    @Transactional
    public PointsExchangeResponseDto approveExchange(Long requestId) {

        PointsHistory history = pointsHistoryRepository.findAndLockById(requestId)
                .orElseThrow(() -> new CommonException(ErrorCode.ENTITY_NOT_FOUND, "ì¶œê¸ˆ ?”ì²­??ì°¾ì„ ???†ìŠµ?ˆë‹¤. requestId=" + requestId));

        if (history.getStatus() != PointsStatus.APPLY) {
            throw new CommonException(ErrorCode.CONFLICT, "?´ë? ì²˜ë¦¬???”ì²­?…ë‹ˆ??);
        }

        Users user = userRepository.findByIdForUpdate(history.getUser().getId())
                .orElseThrow(() -> new CommonException(ErrorCode.ENTITY_NOT_FOUND, "?¬ìš©?ë? ì°¾ì„ ???†ìŠµ?ˆë‹¤. Id= " + history.getUser().getId()));

        int amount = history.getAmount();
        String message;

        if (user.getPoints() < amount) {
            history.markFailed(INSUFFICIENT_POINTS_FAIL_REASON, LocalDateTime.now(clock));
            message = "?¬ì¸?¸ê? ë¶€ì¡±í•˜???¤íŒ¨?ˆìŠµ?ˆë‹¤.";
        } else {
            user.subtractPoints(amount);
            history.markSuccess(LocalDateTime.now(clock));
            message = "?•ìƒ?ìœ¼ë¡?ì²˜ë¦¬?˜ì—ˆ?µë‹ˆ??";
        }

        return PointsExchangeResponseDto.builder()
                .requestId(requestId)
                .userId(user.getId())
                .exchangeAmount(amount)
                .status(history.getStatus())
                .message(message)
                .processedDate(history.getProcessedAt())
                .build();
    }

    /* ? ì§œ ?Œì‹± */
    private LocalDateTime parseStartDate(String date) {
        if (date == null || date.isEmpty()) return null;
        try {
            return LocalDate.parse(date).atStartOfDay();
        } catch (DateTimeParseException e) {
            throw new CommonException(ErrorCode.INVALID_REQUEST, "startDate ?•ì‹???˜ëª» ?…ë ¥?ˆìŠµ?ˆë‹¤. ?? 2025-11-01");
        }
    }

    private LocalDateTime parseEndDate(String date) {
        if (date == null || date.isEmpty()) return null;
        try {
            return LocalDate.parse(date).atTime(23, 59, 59);
        } catch (DateTimeParseException e) {
            throw new CommonException(ErrorCode.INVALID_REQUEST, "endDate ?•ì‹???˜ëª» ?…ë ¥?ˆìŠµ?ˆë‹¤. ?? 2025-11-30");
        }
    }

    private String mapStatusToMessage(PointsStatus status) {
        return switch (status) {
            case APPLY -> "ì¶œê¸ˆ ? ì²­ ì²˜ë¦¬ ì¤‘ì…?ˆë‹¤.";
            case SUCCESS -> "ì¶œê¸ˆ???„ë£Œ?˜ì—ˆ?µë‹ˆ??;
            case FAILED -> "ì¶œê¸ˆ ? ì²­???¤íŒ¨?ˆìŠµ?ˆë‹¤.";
        };
    }
}


